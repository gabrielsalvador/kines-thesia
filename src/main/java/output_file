package me.gabrielsalvador;         public class Config {     public static final String RESOURCES_PATH = "src/main/resources";     public static final String ICON_FOLDER_PATH = RESOURCES_PATH + "/icons";     public static final Map<Class<? extends Tool>, String> toolIconNames = Map.of(             SelectTool.class, "selectTool.png",             AddTool.class,"addTool.png");            public static final int THEME_COLOR_SELECTED = Color.rgbToInt(100,217,244);       public static class Shortcuts {         public static final char CLONE = 'c';         // Add more shortcuts here if needed     } } package me.gabrielsalvador.tools;               @SkipProcessing public class CommandTool extends Tool {      private Textfield _textfield;      public CommandTool() {         ControlP5 cp5 = Sinesthesia.getInstance().getCP5();         int x = cp5.getPointer().getX();         int y = cp5.getPointer().getY();         _textfield = (Textfield) cp5.getController("CommandTextfield");         if (_textfield == null) {             _textfield = cp5.addTextfield("CommandTextfield");         }         _textfield.show();         _textfield.setFocus(true);         _textfield.skipNextEvent();         _textfield.getKeyMapping().put((int) PApplet.ENTER, new EnterCommand());         _textfield.setPosition(x, y - 40);         CanvasController canvas = (CanvasController) cp5.getController("MainCanvas");         canvas.setUserInteraction(false);       }      @Override     public void keyEvent(KeyEvent keyEvent) {      }      @Override     public void onClick(int x, int y) {      }      @Override     public void onPressed(int x, int y) {      }      @Override     public void onRelease(int x, int y) {      }      @Override     public void onDrag(int x, int y) {      }       public void setFocus(boolean focus) {         _textfield.setFocus(focus);     }        class EnterCommand implements TextfieldCommand {          @Override         public void execute() {             ControlP5 cp5 = Sinesthesia.getInstance().getCP5();              CanvasController canvas = (CanvasController) cp5.getController("MainCanvas");             canvas.setUserInteraction(true);              Textfield tf = (Textfield) _textfield;             String command = tf.getText();             String split[] = command.split(" ");             if (split[0].equals("add")) {                 String[] args = command.split(" ");                 int x = canvas.getPointer().x();                 int y = canvas.getPointer().y();                 if(args[1].equals("keyboard")){                     PKeyboard pKeyboard = new PKeyboard();                     pKeyboard.setPosition(new float[]{x,y});                     AppController.getInstance().addPObject(pKeyboard);                 }else {                     AppController.getInstance().addPlayableNote(new Vector(x,y));                 }             }else if(split[0].equals("clear")) {                 AppController.getInstance().clearObjects();             }              _textfield.clear();             _textfield.hide();         }     } } package me.gabrielsalvador.tools;              public class ToolManager  {     private static ToolManager _instance;     private Tool _currentTool = new SelectTool();      protected Set<Class<? extends Tool>> tools = new HashSet<>();     protected Map<Character, Class<? extends Tool>> keyMappings = new HashMap<>();     private final PropertyChangeSupport _propertyChangeSupport = new PropertyChangeSupport(this);       private ToolManager() {         loadToolClasses();     }      public static synchronized ToolManager getInstance() {         if (_instance == null) {             _instance = new ToolManager();         }          return _instance;     }      public Tool getCurrentTool() {         return _currentTool;     }      public void setCurrentTool(Tool tool) {         Tool oldTool = this._currentTool;         this._currentTool = tool;         _propertyChangeSupport.firePropertyChange("currentTool", oldTool, tool);     }      public void setCurrentTool(Class<? extends Tool> tool) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {         Tool newTool = tool.getConstructor().newInstance();         setCurrentTool(newTool);     }     private void loadToolClasses() {          Reflections reflections = new Reflections("me.gabrielsalvador.tools");         Set<Class<? extends Tool>> toolClasses = reflections.getSubTypesOf(Tool.class);          for (Class<? extends Tool> toolClass : toolClasses) {             if (!Modifier.isAbstract(toolClass.getModifiers())) { // Exclude abstract classes                 tools.add(toolClass);                 char key = getShortcutForTool(toolClass);                 keyMappings.put(key, toolClass);             }         }     }      private char getShortcutForTool(Class<? extends Tool> toolClass) {         switch (toolClass.getSimpleName()) {             case "SelectTool":                 return 's';             case "MoveTool":                 return 'm';             case "AddTool":                 return 'a';             case "CommandTool":                 return 'n';             default:                 return '\0';         }      }     public void keyEvent(KeyEvent event) {         char key = Character.toLowerCase(event.getKey());          //tool keyboard shortcuts         if (keyMappings.containsKey(key)) {             // Instantiate the tool class and set it as the current tool.             try {                 Class<? extends Tool> toolClass = keyMappings.get(key);                 Tool newTool = toolClass.getDeclaredConstructor().newInstance();                 setCurrentTool(newTool);              } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {                 e.printStackTrace();             }          }         //send KeyEvent to tool         _currentTool.keyEvent(event);      }      public Set<Class<? extends Tool>> getTools() {         return tools;     }      public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {         _propertyChangeSupport.addPropertyChangeListener(propertyName, listener);     }   } package me.gabrielsalvador.tools;                 public class SelectTool extends Tool {      private ControlP5 _cp5;     private PVector startPoint = null;     private PVector endPoint = null;     private PObject selectedObject = null;     private boolean isCloning = false; // Keep track of whether the object is being cloned     private PObject clonedObject = null; // Reference to the cloned object     private final PropertyChangeSupport _propertyChangeSupport = new PropertyChangeSupport(this);      public SelectTool() {         _cp5 = Sinesthesia.getInstance().getCP5();     }      @Override     public void keyEvent(KeyEvent keyEvent) {      }      @Override     public void onClick(int x, int y) {      }      @Override     public void onPressed(int x, int y) {         ArrayList<PObject> pObjects = AppState.getInstance().getPObjects();         selectedObject = null;         for (PObject pObject : pObjects) {             View<PObject> view = pObject.getView();             if (view.isMouseOver(x, y)) {                  pObject.setIsSelected(true);                 selectedObject = pObject;                 startPoint = new PVector(x, y);                  // Check if the meta key is down to decide whether to clone                 isCloning = _cp5.isAltDown();                  if (isCloning) {                     // Clone the selected object and add it to the scene                     clonedObject = selectedObject.clone();                     AppState.getInstance().getGizmos().add(clonedObject.getView());                 }             } else {                 pObject.setIsSelected(false);             }         }         AppController.getInstance().firePropertyChange("selectedObjects", null, selectedObject);     }         @Override     public void onDrag(int x, int y) {         if (selectedObject != null && startPoint != null) {             PVector currentPosition = new PVector(x, y);             PVector displacement = PVector.sub(currentPosition, startPoint);              if (isCloning) {                 // Update the position of the cloned object                 float[] objPosition = clonedObject.getPosition();                 objPosition[0] += displacement.x;                 objPosition[1] += displacement.y;                 clonedObject.setPosition(objPosition);             } else {                 // Update the position of the selected object                 float[] objPosition = selectedObject.getPosition();                 objPosition[0] += displacement.x;                 objPosition[1] += displacement.y;                 selectedObject.setPosition(objPosition);             }              startPoint = currentPosition;         }     }      @Override     public void onRelease(int x, int y) {          //add object and remove gizmo         if (isCloning) {             AppState.getInstance().addPObject(clonedObject);             AppState.getInstance().getGizmos().remove(clonedObject.getView());         }           startPoint = null;         endPoint = null;         selectedObject = null;         isCloning = false;         clonedObject = null;      }      public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {         _propertyChangeSupport.addPropertyChangeListener(propertyName, listener);     } }  package me.gabrielsalvador.tools;        public abstract class Tool implements Serializable {     private String _name;     private String _description;           public Tool() {              }      public String getName() {         return _name;     }      public String getDescription() {         return _description;     }          public void setDescription(String description) {         _description = description;     }      public abstract void keyEvent(KeyEvent keyEvent);      public abstract void onClick(int x, int y) ;       public abstract void onPressed(int x, int y);     public abstract void onRelease(int x, int y) ;      // Add this method to handle mouse drag events     public abstract void onDrag(int x, int y); } package me.gabrielsalvador.tools;     public class AddTool extends Tool {      public AddTool() {              }      @Override     public void keyEvent(KeyEvent keyEvent) {      }       @Override     public void onClick(int x, int y) {               }      @Override     public void onPressed(int x, int y) {      }      @Override     public void onRelease(int x, int y) {      }      @Override     public void onDrag(int x, int y) {      }   } package me.gabrielsalvador.tools;            public class ToolboxController extends Group {      final private Map<Class<? extends Tool>, Button> _children = new HashMap<>();      public ToolboxController(ControlP5 theControlP5, String theName) {         super(theControlP5, theName);      }       public void didSetupLayout() {         Set<Class<? extends Tool>> tools = ToolManager.getInstance().getTools();         for (Class<? extends Tool> tool : tools) {             if (tool.isAnnotationPresent(SkipProcessing.class)) {                 continue;             }             String uii = UUID.randomUUID().toString();             Button b = new Button(cp5, uii);             b.addListener(new ControlListener() {                 @Override                 public void controlEvent(ControlEvent controlEvent) {                     try {                         ToolManager.getInstance().setCurrentTool(tool);                     } catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {                         e.printStackTrace();                     }                 }             });             b.setSwitch(true);             _children.put(tool, b);               ToolManager.getInstance().addPropertyChangeListener("currentTool", new PropertyChangeListener() {                 @Override                 public void propertyChange(PropertyChangeEvent evt) {                     updateButtonStates((Tool) evt.getOldValue(), (Tool) evt.getNewValue());                 }             });             ;             b.setWidth(getWidth());             addChildHorizontally(b);         }     }       private void updateButtonStates(Tool oldTool, Tool newTool) {         if (oldTool != null) {             Button oldButton = _children.get(oldTool.getClass());             if (oldButton != null) oldButton.updateOn(false);         }         if (newTool != null) {             Button newButton = _children.get(newTool.getClass());             if (newButton != null) newButton.updateOn(true);         }     }   } package me.gabrielsalvador.core;          public class AppController {     private static AppController _instance;     private final PropertyChangeSupport _propertyChangeSupport = new PropertyChangeSupport(this);       private AppController() {      }      public static synchronized AppController getInstance() {         if (_instance == null) {             _instance = new AppController();         }          return _instance;     }      public void addPObject(PObject pObject) {         AppState.getInstance().addPObject(pObject);     }      public PlayableNote addPlayableNote(Vector position) {         PlayableNote note = new PlayableNote().setPosition(position);         AppState.getInstance().addPObject(note);         return note;     }      public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {         _propertyChangeSupport.addPropertyChangeListener(propertyName, listener);     }      public void firePropertyChange(String propertyName, Object oldValue, Object newValue) {         _propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);     }       public void clearObjects() {         AppState.getInstance().clearObjects();     } } package me.gabrielsalvador.core;          // Custom controller class that extends Controller public class CanvasController extends Controller<CanvasController> implements ReleasedOutsideListener {      private final ToolManager _toolManager;      public CanvasController(ControlP5 cp5, String name) {         super(cp5, name);         _myControllerView = new CanvasView();         _toolManager = ToolManager.getInstance();     }       @Override     public void onPress() {         isActive = inside();         setUserInteraction(isActive);         // x and y are relative to the canvas         int x = cp5.getPointer().getX() - (int) absolutePosition[0];         int y = cp5.getPointer().getY() - (int) absolutePosition[1];         _toolManager.getCurrentTool().onPressed(x, y);     }      @Override     public void mousePressed() {         super.mousePressed();       Textfield t = (Textfield) cp5.get("CommandTextfield");       if (t != null) {         t.hide();         t.clear();       }      }      @Override     public void mouseReleasedOutside() {         isActive = false;     }      @Override     public void onDrag() {         // x and y are relative to the canvas         int x = cp5.getPointer().getX() - (int) absolutePosition[0];         int y = cp5.getPointer().getY() - (int) absolutePosition[1];         _toolManager.getCurrentTool().onDrag(x, y);      }      @Override     public void onRelease() {         // x and y are relative to the canvas         int x = cp5.getPointer().getX() - (int) absolutePosition[0];         int y = cp5.getPointer().getY() - (int) absolutePosition[1];         _toolManager.getCurrentTool().onRelease(x, y);     }      @Override     public void onMove() {       }      @Override     public void onClick() {      }      @Override     public void onScroll(int theRotationValue) {      }      @Override     public void keyEvent(KeyEvent theKeyEvent) {         if (isUserInteraction && isActive && theKeyEvent.getAction() == KeyEvent.PRESS) {              _toolManager.keyEvent(theKeyEvent);          }      }      @Override     public void draw(PGraphics graphics) {          graphics.pushMatrix();         graphics.translate(x(position), y(position));         getView().display(graphics, this);         graphics.popMatrix();      }  } package me.gabrielsalvador.core;                public class Sinesthesia extends PApplet {      private static Sinesthesia _instance;     private ControlP5 _cp5;      public Sinesthesia() {         super();         _instance = this;      }      public static synchronized Sinesthesia getInstance() {         if (_instance == null) {             _instance = new Sinesthesia();         }          return _instance;     }      public static void main(String[] args) {         PApplet.main("me.gabrielsalvador.core.Sinesthesia");     }      public void settings() {         size(1280,820,P2D);         registerMethod("dispose", this);     }      public void setup() {         background(0);         _cp5 = new ControlP5(this);         smooth();         PFont   myFont = createFont("fonts/CascadiaCode_VTT.ttf", 12, true);         ControlFont cfont = new ControlFont(myFont);         _cp5.setFont(cfont);           loadAppState();          LayoutBuilder builder = new LayoutBuilder(this, _cp5);         builder.addCustomClasses("Canvas", CanvasController.class);         builder.addCustomClasses("Toolbox", ToolboxController.class);         builder.addCustomClasses("Inspector", InspectorController.class);          try {             Path xmlPath = Paths.get(Config.RESOURCES_PATH+"/mainLayout.xml");             String xmlContent = new String(Files.readAllBytes(xmlPath));             builder.parseXML(xmlContent);         } catch (Exception e) {              e.printStackTrace();         }         }      public void draw() {         background(255);     }      public ControlP5 getCP5() {         return _cp5;     }      private void loadAppState() {         try (FileInputStream fileIn = new FileInputStream("appState.ser");              ObjectInputStream in = new ObjectInputStream(fileIn)) {             AppState loadedState = (AppState) in.readObject();             AppState.getInstance().setCurrentTool(loadedState.getCurrentTool());             for (PObject pObject : loadedState.getPObjects()) {                 AppState.getInstance().addPObject(pObject);             }         } catch (IOException | ClassNotFoundException e) {             e.printStackTrace();         }     }     public void dispose() {         // Save the app state         try (FileOutputStream fileOut = new FileOutputStream("appState.ser");              ObjectOutputStream out = new ObjectOutputStream(fileOut)) {             out.writeObject(AppState.getInstance());         } catch (IOException e) {             e.printStackTrace();         }         //terminate app          super.dispose();      }  } package me.gabrielsalvador.core;           public class AppState implements Serializable {     private static AppState _instance;      private Tool _currentTool;     private final ArrayList<View> _gizmos = new ArrayList<View>();     private final ArrayList<PObject> _pObjects = new ArrayList<PObject>();      private AppState() {}       public static synchronized AppState getInstance() {         if (_instance == null) {             _instance = new AppState();         }          return _instance;     }       public Tool getCurrentTool() {         return _currentTool;     }       public void setCurrentTool(Tool currentTool) {         this._currentTool = currentTool;     }           public ArrayList<PObject> getPObjects() {         return _pObjects;     }     public ArrayList<View> getGizmos() {  return _gizmos;}      public void addPObject(PObject pObject) {         _pObjects.add(pObject);     }      public void clearObjects() {         _pObjects.clear();     } } package me.gabrielsalvador.utils;    /* just a wrapper for the processing class PVector */ public class Vector {         private PVector pVector;              public Vector() {             this.pVector = new PVector();         }              public Vector(float x, float y) {             this.pVector = new PVector(x, y);         }              public Vector(float x, float y, float z) {             this.pVector = new PVector(x, y, z);         }                  public PVector getPVector() {             return this.pVector;         }                  public boolean equals(Vector v) {             return this.pVector.equals(v.getPVector());         }                  public float getX() {             return this.pVector.x;         }          public float getY() {             return this.pVector.y;         } }     package me.gabrielsalvador.utils;  public class MathUtils {     public static float distance(float x1, float y1, float x2, float y2) {         return (float) java.lang.Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));     } } package me.gabrielsalvador.utils;  public class Color {     public static int rgbToInt(int r, int g, int b) {         return (255 << 24) | (r << 16) | (g << 8) | b;     } } package me.gabrielsalvador.common;    @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface SkipProcessing { }package me.gabrielsalvador.views;            public class CanvasView implements ControllerView<CanvasController> {      private ArrayList<PObject> pObjects;     private ArrayList<View> gizmos;      public CanvasView() {         pObjects = AppState.getInstance().getPObjects();         gizmos = AppState.getInstance().getGizmos();     }       @Override     public void display(PGraphics graphics, CanvasController controller) {       graphics.pushStyle();       graphics.strokeWeight(1);                 if (controller.isActive()) {         graphics.stroke(127);       } else {         graphics.stroke(0);       }       graphics.rect(0,0,controller.getWidth(),controller.getHeight());        /*draw pobjects*/         for (PObject pObject : pObjects) {             pObject.getView().display(graphics);          }       graphics.popStyle();          gizmos.forEach(gizmo -> gizmo.display(graphics));     }   }package me.gabrielsalvador.views;    public interface View<T> {           public T getModel();      public void display(PGraphics graphics);     public boolean isMouseOver(int mouseX, int mouseY); } package me.gabrielsalvador.pobject;       @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Property {     String name();      Class<?> type(); } package me.gabrielsalvador.pobject;             @Properties({         @Property(name = "position", type = float[].class), })  public class PObject implements Serializable  {       private boolean _isSelected = false;     private final Set<PObject> _children = new HashSet<PObject>();     private final LinkedHashMap<String, PObjectProperty> _properties = new LinkedHashMap<String, PObjectProperty>();     private final LinkedHashMap<String,PObject> _subObjects = new LinkedHashMap<String,PObject>();     transient private View<PObject> _view;       public PObject() {         /* Walks up the class hierarchy to get all annotations concerning the properties and inlets */         Class<?> currentClass = this.getClass();         while (currentClass != null) {             Properties propertiesAnnotation = currentClass.getAnnotation(Properties.class);             if (propertiesAnnotation != null) {                 // Handling properties annotation                 for (Property propertyAnnotation : propertiesAnnotation.value()) {                     String name = propertyAnnotation.name();                     Class<?> type = propertyAnnotation.type();                      PObjectProperty property = new PObjectProperty(name, type);                     property.setValue(Defaults.getDefaultValue(type));                      addProperty(property);                 }             }              InletsAnnotation inletsAnnotation = currentClass.getAnnotation(InletsAnnotation.class);             if (inletsAnnotation != null) {                  for (InletAnnotation inletAnnotation : inletsAnnotation.value()) {                     String name = inletAnnotation.name();                     Class<?> type = inletAnnotation.type();                       PatchSocket patchSocket = new PatchSocket(this);                     AppController.getInstance().addPObject(patchSocket);                 }             }              currentClass = currentClass.getSuperclass();         }     }        public PObject setPosition(float[] position) {         PObjectProperty property = getProperty("position");         property.setValue(position);         return this;     }      public float[] getPosition() {         return (float[])getProperty("position").getValue();     }      public PObject setSize(float[] size) {         getProperty("size").setValue(size);         return this;     }      public float[] getSize() {         return (float[])getProperty("size").getValue();     }       public PObject setIsSelected(boolean selectedState){         _isSelected = selectedState;         return this;     }      public boolean getIsSelected(){         return _isSelected;     }        public Set<PObject> addChild(PObject pObject) {         _children.add(pObject);         return _children;     }        public Set<PObject> getChildren() {         return _children;     }       public LinkedHashMap<String,PObject> getSubObjects() {         return _subObjects;     }          public PObjectProperty getProperty(String name) {         return _properties.get(name);     }       public PObject addProperty(PObjectProperty property) {         _properties.put(property.getName(), property);         return this;     }     public HashMap<String, PObjectProperty> getProperties () {         return _properties;     }      public PObject addProperties(Map<String,PObjectProperty> properties) {         //add properties to the object         for (String key : properties.keySet()) {             addProperty(properties.get(key));         }         return this;     }       public View<PObject> getView() {         return _view;     }      public PObject setView(View<PObject> view) {         _view = view;         return this;     }      public PObject clone() {         try {             // Serialize the current object to a byte array             ByteArrayOutputStream byteStream = new ByteArrayOutputStream();             ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteStream);             objectOutputStream.writeObject(this);              // Deserialize the byte array to create a new instance (clone) of the object             ByteArrayInputStream byteInputStream = new ByteArrayInputStream(byteStream.toByteArray());             ObjectInputStream objectInputStream = new ObjectInputStream(byteInputStream);             return (PObject) objectInputStream.readObject();         } catch (IOException | ClassNotFoundException e) {             e.printStackTrace();         }         return null;     }   }package me.gabrielsalvador.pobject;          public class InspectorController extends Group implements PropertyChangeListener {      private int DEFAULT_HEIGHT = 30;     private PObject _object;      public InspectorController(ControlP5 theControlP5, String theName) {         super(theControlP5, theName);         AppController.getInstance().addPropertyChangeListener("selectedObjects", this);     }       @Override     public void didSetupLayout() {      }       @Override     public void propertyChange(PropertyChangeEvent evt) {         this.clear();         if (evt.getNewValue() == null) return;         if (!(evt.getNewValue() instanceof PObject selectedObject)) return;         if (!evt.getPropertyName().equals("selectedObjects")) return;          /* Get the properties from the object */         HashMap<String, PObjectProperty> properties = selectedObject.getProperties();          /* Iterate over the properties and build the controllers to change them*/         for (String key : properties.keySet()) {             PObjectProperty property = properties.get(key);             Class<?> type = property.getType();              buildGroupForProperty(property, type);         }      }      private void buildGroupForProperty(PObjectProperty property, Class<?> type) {         /* Build a Group for each property          * 50% of the width for the label          * 50% of the width for the controller          * */          Group container = new Group(cp5, "PropertyGroup" + property.getName());         container.setWidth(getWidth());         container.setHeight(DEFAULT_HEIGHT);         container.hideBar();          /* Build the label */         Textlabel label = new Textlabel(cp5, "label" + property.getName());         label.moveTo(container);         label.setText(property.getName());         label.setHeight(container.getHeight());           /* Build the controller */         Controller<?>[] controllers = buildControllerForProperty(container, property, type);         /* puts all controllers in place and adds a listener for then values change*/         for(int i= 0; i < controllers.length; i++) {             controllers[i].setWidth(container.getWidth()/2/controllers.length);             controllers[i].setPosition(container.getWidth()/2 + (container.getWidth()/2/controllers.length) * (i), 0);             controllers[i].setHeight(container.getHeight());             controllers[i].setGroup(container);             controllers[i].addListener(new ControlListener() {                 public void controlEvent(ControlEvent theEvent) {                     //if property is a vector                     if (type.getName().equals("[F")) {                         float[] vector = new float[controllers.length];                         for (int i = 0; i < controllers.length; i++) {                             vector[i] = controllers[i].getValue();                         }                         property.setValue(vector);                     } else {                         property.setValue(theEvent.getController().getValue());                     }                 }             });         }            /* Add the group to the inspector */         addChildVertically(container);         //container.moveTo(this);      }      private Controller[] buildControllerForProperty(Group container, PObjectProperty property, Class<?> type) {         if (type == Boolean.class) {             Toggle toggle = cp5.addToggle(property.getName())                     .setPosition(0, 0)                     .setSize(20, 20)                     .setGroup(this)                     .setValue((Boolean) property.getValue());             return new Controller[]{toggle};         } else if (type == Integer.class) {             Numberbox numberbox = cp5.addNumberbox(property.getName())                     .setPosition(0, 0)                     .setSize(100, 20)                     .setGroup(this)                     .setValue((Integer) property.getValue());             return new Controller[]{numberbox};         } else if (type == Float.class) {             Numberbox numberbox = cp5.addNumberbox(property.getName())                     .setPosition(0, 0)                     .setSize(100, 20)                     .setGroup(this)                     .setValue((Float) property.getValue());             return new Controller[]{numberbox};         } else if (type == String.class) {             Textfield textfield = cp5.addTextfield(property.getName())                     .setPosition(0, 0)                     .setSize(100, 20)                     .setGroup(this)                     .setValue((String) property.getValue());             return new Controller[]{textfield};         } else if (type == PVector.class) {             Numberbox numberbox = cp5.addNumberbox(property.getName())                     .setPosition(0, 0)                     .setSize(100, 20)                     .setGroup(this)                     .setValue((Float) property.getValue());             return new Controller[]{numberbox};         } else if (type.getName().equals("[F")) {             float[] vector = (float[]) property.getValue();              Controller[] controllers = new Controller[vector.length];              for (int i = 0; i < vector.length; i++) {                 Numberbox numberbox = cp5.addNumberbox(property.getName() + i)                         .setPosition(0, 0)                         .setSize((container.getWidth()/2) / vector.length, 20)                         .setValue(vector[i]);                 numberbox.getCaptionLabel().hide();                  controllers[i] = numberbox;             }             return controllers;          }         Textlabel t = new Textlabel(cp5, "Property" + property.getName());         String typeName = type.getName().substring(0, Math.min(type.toString().length(), 10));          t.setText(typeName + " Not Implmtld");         return new Controller[]{t};      } } package me.gabrielsalvador.pobject;    public class PObjectProperty implements Serializable {     private String name;     private Object value;     private Class<?> type;      public PObjectProperty(String name, Class<?> type) {         this.name = name;         this.type = type;     }      public String getName() {         return name;     }      public PObjectProperty setValue(Object value) {         this.value = value;         return this;     }      public Object getValue() {         return value;     }      public Class<?> getType() {         return type;     } } package me.gabrielsalvador.pobject;         public class PlayableNoteView extends PObjectView implements View<PObject> {      private PObject _model;      public PlayableNoteView(PObject model) {         super(model);         _model = model;         _model.setView(this);     }      public PObject getModel() {         return _model;     }      public void display(PGraphics graphics) {         super.display(graphics);         Vector position = getPosition();         float radius = _model.getSize()[0];          graphics.ellipseMode(PApplet.CENTER);          graphics.pushStyle();         graphics.strokeWeight(1);         if(_model.getIsSelected()){             graphics.stroke(Config.THEME_COLOR_SELECTED);             graphics.fill(Config.THEME_COLOR_SELECTED);          }else {             graphics.stroke(0);             graphics.fill(255, 255, 255);         }         graphics.ellipse(position.getX(), position.getY(), radius, radius);         graphics.popStyle();      }      public boolean isMouseOver(int mouseX, int mouseY) {         Vector position = getPosition();         float radius = _model.getSize()[0]/2;          // inside the circle         float d = MathUtils.distance(mouseX, mouseY, position.getX(), position.getY());         if (d < Math.abs(radius)) {             return true;         }          return false;      }      public Vector getPosition() {         return new Vector(_model.getPosition()[0], _model.getPosition()[1]);     }   }package me.gabrielsalvador.pobject;       @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Properties {     Property[] value(); } package me.gabrielsalvador.pobject;     public class PObjectView implements View<PObject> {      private PObject _model;      public PObjectView(PObject model) {         _model = model;     }      @Override     public PObject getModel() {         return _model;     }      @Override     public void display(PGraphics graphics) {          for (String subObject : _model.getSubObjects().keySet()) {             View view = _model.getSubObjects().get(subObject).getView();             if (view != null) view.display(graphics);         }     }      @Override     public boolean isMouseOver(int mouseX, int mouseY) {         return false;     } } package me.gabrielsalvador.pobject;  public class Defaults {     public static final int[] DEFAULT_KEYBOARD_SIZE = new int[]{50,15};     static float DEFAULT_NOTE_SIZE = 5;      public static Object getDefaultValue(Class<?> type) {         if (type == Integer.class) {             return 0;         } else if (type == Float.class) {             return 0.0f;         } else if (type == Boolean.class) {             return false;         } else if (type == String.class) {             return "";         } else if (type == Integer[].class) {             return new Integer[0];         } else if (type.getName().equals("[F")) {             return new float[]{0.0f, 0.0f};         } else if (type.getName().equals("[Ljava.lang.String;")) {             return new String[0];         } else if (type.getName().equals("[Ljava.lang.Integer;")) {             return new Integer[0];         } else if (type.getName().equals("[Ljava.lang.Float;")) {             return new Float[0];         } else if (type.getName().equals("[Z")) {             return new boolean[0];         } else if (type.getName().equals("[Ljava.lang.Boolean;")) {             return new Boolean[0];         } else {             return null;         }     } } package me.gabrielsalvador.pobject;             @InletsAnnotation({         @InletAnnotation(name = "trigger", type = Trigger.class), }) public class PKeyboard extends PObject implements Outlet<Trigger> {      HashSet<Patchcords> patchcords = new HashSet<>();      public PKeyboard() {         super();         setView(new PKeyboardView(this));      }       @Serial     private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {         // default deserialization         aInputStream.defaultReadObject();          setView(new PKeyboardView(this));      }      @Override     public void send(Trigger message) {         patchcords.forEach(patchcord -> patchcord.send(message));     } } package me.gabrielsalvador.pobject;    public class PObjectController {       private PObject _model;      public PObjectController(PObject model) {         _model = model;     }       }  package me.gabrielsalvador.pobject;       public class PKeyboardView extends PObjectView implements View<PObject> {      private PObject _model;      public PKeyboardView(PObject model) {         super(model);         _model = model;         _model.setView(this);     }      public PObject getModel() {         return _model;     }      public void display(PGraphics graphics) {         super.display(graphics);         float[] position = _model.getPosition();          float keyWidth = (float) Defaults.DEFAULT_KEYBOARD_SIZE[0] / 7;         float keyHeight = Defaults.DEFAULT_KEYBOARD_SIZE[1];          float offsetX = position[0] - keyWidth * 7 / 2;         float offsetY = position[1] - keyHeight / 2;          // Change stroke color when selected         if (_model.getIsSelected()) {             graphics.stroke(255, 0, 0);  // Red stroke         } else {             graphics.stroke(0);  // Black stroke         }          // draw white keys         graphics.fill(255);  // white         for (int i = 0; i < 7; i++) {             graphics.rect(offsetX + i * keyWidth, offsetY, keyWidth, keyHeight);         }          // draw black keys         graphics.fill(0);  // black         for (int i = 0; i < 7; i++) {             if (i != 2 && i != 6) {  // skip the 3rd and 7th position for black keys                 graphics.rect(offsetX + i * keyWidth + keyWidth / 2, offsetY, keyWidth / 2, keyHeight / 2);             }         }     }       public boolean isMouseOver(int mouseX, int mouseY) {         float[] position = _model.getPosition();          float keyWidth = Defaults.DEFAULT_KEYBOARD_SIZE[0];         float keyHeight = Defaults.DEFAULT_KEYBOARD_SIZE[1];          float offsetX = position[0] - keyWidth / 2;         float offsetY = position[1] - keyHeight / 2;          return mouseX >= offsetX && mouseX <= offsetX + keyWidth                 && mouseY >= offsetY && mouseY <= offsetY + keyHeight;     }      }package me.gabrielsalvador.pobject;        @Properties({         @Property(name = "size", type = float[].class),         @Property(name = "pitch", type = Integer.class),         @Property(name = "attack", type = Float.class),         @Property(name = "decay", type = Float.class),         @Property(name = "sustain", type = Float.class),         @Property(name = "release", type = Float.class) })  public class PlayableNote extends PObject{       public PlayableNote() {         super();         setPosition(new Vector(0, 0));         setSize((Defaults.DEFAULT_NOTE_SIZE));         setView(new PlayableNoteView(this));     }       public PlayableNote setPosition(Vector position) {         //convert Vector to float[]         float[] pos = new float[2];         pos[0] = position.getX();         pos[1] = position.getY();         super.setPosition(pos);         return this;     }       public PlayableNote setSize(float size) {         //convert Vector to float[]         float[] s = new float[2];         s[0] = size;         super.setSize(s);         return this;     }       private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {         // default deserialization         aInputStream.defaultReadObject();          setView(new PlayableNoteView(this));      } } package me.gabrielsalvador.pobject.routing;  public interface Outlet<T> {     void send(T message);  } package me.gabrielsalvador.pobject.routing;  public interface Inlet<T> {     void receive(T message); } package me.gabrielsalvador.pobject.routing;  public class Trigger { } package me.gabrielsalvador.pobject.routing;    public class Patchcords implements Serializable {     private final Outlet outlet;     private final Inlet inlet;      public Patchcords(Outlet outlet, Inlet inlet) {         this.outlet = outlet;         this.inlet = inlet;     }      public void send(Object message) {         this.inlet.receive(message);     } } package me.gabrielsalvador.pobject.routing;            public class PatchSocket extends PObject implements Serializable {      private final int SOCKET_SIZE = 10;     private final int Y_OFFSET = 20;     private final PObject owner;      public PatchSocket( PObject owner) {         this.owner = owner;         this.setView(new PatchSocketView(owner));     }      @Serial     private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {         // default deserialization         aInputStream.defaultReadObject();          setView(new PatchSocketView(owner));      }      private class PatchSocketView  implements View<PObject> {          private  PObject _model;         public PatchSocketView(PObject model) {             _model = model;         }          @Override         public PObject getModel() {             return _model;         }          @Override         public void display(PGraphics graphics) {             //if selected change color             if (_model.getIsSelected()) {                 graphics.fill(255, 0, 0);             } else {                 graphics.fill(0);             }             float[] position = (float[])_model.getProperty("position").getValue();             graphics.fill(255, 255,255);             graphics.pushMatrix();             graphics.translate(position[0], position[1]);             graphics.ellipseMode(PApplet.CENTER);             graphics.ellipse(0, Y_OFFSET,SOCKET_SIZE,SOCKET_SIZE);             graphics.popMatrix();         }          @Override         public boolean isMouseOver(int mouseX, int mouseY) {             float[] position = (float[])_model.getProperty("position").getValue();             float centerX = position[0];             float centerY = position[1] + Y_OFFSET;              float distance = PApplet.dist(mouseX, mouseY, centerX, centerY);              boolean isOver =  distance <= SOCKET_SIZE / 2;             System.out.println("distance: " + distance + " isOver: " + isOver);             return isOver;         }      } }  package me.gabrielsalvador.pobject.routing.annotations;       @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface InletAnnotation {     String name();     Class<?> type(); }  package me.gabrielsalvador.pobject.routing.annotations;       @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface InletsAnnotation {     InletAnnotation[] value(); }  